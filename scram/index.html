<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `scram` crate."><meta name="keywords" content="rust, rustlang, rust-lang, scram"><title>scram - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate scram</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'scram', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/scram/lib.rs.html#1-146' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>scram</a></span></h1><div class='docblock'><h1 id="salted-challenge-response-authentication-mechanism-scram" class="section-header"><a href="#salted-challenge-response-authentication-mechanism-scram">Salted Challenge Response Authentication Mechanism (SCRAM)</a></h1>
<p>This implementation currently provides a client and a server for the SCRAM-SHA-256 mechanism
according to <a href="https://tools.ietf.org/html/rfc5802">RFC5802</a> and
<a href="https://tools.ietf.org/html/rfc7677">RFC7677</a>. It doesn't support channel-binding.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1><h2 id="client" class="section-header"><a href="#client">Client</a></h2>
<p>A typical usage scenario is shown below. For a detailed explanation of the methods please
consider their documentation. In productive code you should replace the unwrapping by proper
error handling.</p>
<p>At first the user and the password must be supplied using either of the methods
<a href="client/struct.ClientFirst.html#method.new"><code>ClientFirst::new</code></a> or
<a href="client/struct.ClientFirst.html#method.with_rng"><code>ClientFirst::with_rng</code></a>. These methods return
a SCRAM state you can use to compute the first client message.</p>
<p>The server and the client exchange four messages using the SCRAM mechanism. There is a rust type
for each one of them. Calling the methods
<a href="client/struct.ClientFirst.html#method.client_first"><code>client_first</code></a>,
<a href="client/struct.ServerFirst.html#method.handle_server_first"><code>handle_server_first</code></a>,
<a href="client/struct.ClientFinal.html#method.client_final"><code>client_final</code></a> and
<a href="client/struct.ServerFinal.html#method.handle_server_final"><code>handle_server_final</code></a> on the
different types advances the SCRAM handshake step by step. Computing client messages never fails
but processing server messages can result in failure.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">scram</span>::<span class="ident">ScramClient</span>;

<span class="comment">// This function represents your I/O implementation.</span>
<span class="kw">fn</span> <span class="ident">send_and_receive</span>(<span class="ident">message</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="macro">unimplemented</span><span class="macro">!</span>()
}

<span class="comment">// Create a SCRAM state from the credentials.</span>
<span class="kw">let</span> <span class="ident">scram</span> <span class="op">=</span> <span class="ident">ScramClient</span>::<span class="ident">new</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="prelude-val">None</span>).<span class="ident">unwrap</span>();

<span class="comment">// Get the client message and reassign the SCRAM state.</span>
<span class="kw">let</span> (<span class="ident">scram</span>, <span class="ident">client_first</span>) <span class="op">=</span> <span class="ident">scram</span>.<span class="ident">client_first</span>();

<span class="comment">// Send the client first message and receive the servers reply.</span>
<span class="kw">let</span> <span class="ident">server_first</span> <span class="op">=</span> <span class="ident">send_and_receive</span>(<span class="kw-2">&amp;</span><span class="ident">client_first</span>);

<span class="comment">// Process the reply and again reassign the SCRAM state. You can add error handling to</span>
<span class="comment">// abort the authentication attempt.</span>
<span class="kw">let</span> <span class="ident">scram</span> <span class="op">=</span> <span class="ident">scram</span>.<span class="ident">handle_server_first</span>(<span class="kw-2">&amp;</span><span class="ident">server_first</span>).<span class="ident">unwrap</span>();

<span class="comment">// Get the client final message and reassign the SCRAM state.</span>
<span class="kw">let</span> (<span class="ident">scram</span>, <span class="ident">client_final</span>) <span class="op">=</span> <span class="ident">scram</span>.<span class="ident">client_final</span>();

<span class="comment">// Send the client final message and receive the servers reply.</span>
<span class="kw">let</span> <span class="ident">server_final</span> <span class="op">=</span> <span class="ident">send_and_receive</span>(<span class="kw-2">&amp;</span><span class="ident">client_final</span>);

<span class="comment">// Process the last message. Any error returned means that the authentication attempt</span>
<span class="comment">// wasn&#39;t successful.</span>
<span class="kw">let</span> () <span class="op">=</span> <span class="ident">scram</span>.<span class="ident">handle_server_final</span>(<span class="kw-2">&amp;</span><span class="ident">server_final</span>).<span class="ident">unwrap</span>();</pre>
<h2 id="server" class="section-header"><a href="#server">Server</a></h2>
<p>The server is created to respond to incoming challenges from a client. A typical usage pattern,
with a default provider is shown below. In production, you would implement an
<code>AuthenticationProvider</code> that could look up user credentials based on a username</p>
<p>The server and the client exchange four messages using the SCRAM mechanism. There is a rust type
for each one of them. Calling the methods
<a href="server/struct.ScramServer.html#method.handle_client_first"><code>handle_client_first</code></a>,
<a href="server/struct.ServerFirst.html#method.server_first"><code>server_first</code></a>,
<a href="server/struct.ClientFinal.html#method.handle_client_final"><code>handle_client_final</code></a> and
<a href="server/struct.ServerFinal.html#method.server_final"><code>server_final</code></a> on the different
types advances the SCRAM handshake step by step. Computing server messages never fails (unless
the source of randomness for the nonce fails), but processing client messages can result in
failure.</p>
<p>The final step will not return an error if authentication failed, but will return an
<a href="server/enum.AuthenticationStatus/html"><code>AuthenticationStatus</code></a> which you can use to determine
if authentication was successful or not.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">scram</span>::{<span class="ident">ScramServer</span>, <span class="ident">AuthenticationStatus</span>, <span class="ident">AuthenticationProvider</span>, <span class="ident">PasswordInfo</span>};

<span class="comment">// Create a dummy authentication provider</span>
<span class="kw">struct</span> <span class="ident">ExampleProvider</span>;
<span class="kw">impl</span> <span class="ident">AuthenticationProvider</span> <span class="kw">for</span> <span class="ident">ExampleProvider</span> {
    <span class="comment">// Here you would look up password information for the the given username</span>
    <span class="kw">fn</span> <span class="ident">get_password_for</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">username</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">PasswordInfo</span><span class="op">&gt;</span> {
       <span class="macro">unimplemented</span><span class="macro">!</span>()
    }

}
<span class="comment">// These functions represent your I/O implementation.</span>
<span class="kw">fn</span> <span class="ident">receive</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="macro">unimplemented</span><span class="macro">!</span>()
}
<span class="kw">fn</span> <span class="ident">send</span>(<span class="ident">message</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) {
    <span class="macro">unimplemented</span><span class="macro">!</span>()
}

<span class="comment">// Create a new ScramServer using the example authenication provider</span>
<span class="kw">let</span> <span class="ident">scram_server</span> <span class="op">=</span> <span class="ident">ScramServer</span>::<span class="ident">new</span>(<span class="ident">ExampleProvider</span>{});

<span class="comment">// Receive a message from the client</span>
<span class="kw">let</span> <span class="ident">client_first</span> <span class="op">=</span> <span class="ident">receive</span>();

<span class="comment">// Create a SCRAM state from the client&#39;s first message</span>
<span class="kw">let</span> <span class="ident">scram_server</span> <span class="op">=</span> <span class="ident">scram_server</span>.<span class="ident">handle_client_first</span>(<span class="kw-2">&amp;</span><span class="ident">client_first</span>).<span class="ident">unwrap</span>();
<span class="comment">// Craft a response to the client&#39;s message and advance the SCRAM state</span>
<span class="comment">// We could use our own source of randomness here, with `server_first_with_rng()`</span>
<span class="kw">let</span> (<span class="ident">scram_server</span>, <span class="ident">server_first</span>) <span class="op">=</span> <span class="ident">scram_server</span>.<span class="ident">server_first</span>().<span class="ident">unwrap</span>();
<span class="comment">// Send our message to the client and read the response</span>
<span class="ident">send</span>(<span class="kw-2">&amp;</span><span class="ident">server_first</span>);
<span class="kw">let</span> <span class="ident">client_final</span> <span class="op">=</span> <span class="ident">receive</span>();

<span class="comment">// Process the client&#39;s challenge and re-assign the SCRAM state.  This could fail if the</span>
<span class="comment">// message was poorly formatted</span>
<span class="kw">let</span> <span class="ident">scram_server</span> <span class="op">=</span> <span class="ident">scram_server</span>.<span class="ident">handle_client_final</span>(<span class="kw-2">&amp;</span><span class="ident">client_final</span>).<span class="ident">unwrap</span>();

<span class="comment">// Prepare the final message and get the authentication status</span>
<span class="kw">let</span>(<span class="ident">status</span>, <span class="ident">server_final</span>) <span class="op">=</span> <span class="ident">scram_server</span>.<span class="ident">server_final</span>();
<span class="comment">// Send our final message to the client</span>
<span class="ident">send</span>(<span class="kw-2">&amp;</span><span class="ident">server_final</span>);

<span class="comment">// Check if the client successfully authenticated</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">status</span>, <span class="ident">AuthenticationStatus</span>::<span class="ident">Authenticated</span>);</pre>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use client::<a class="struct" href="../scram/client/struct.ScramClient.html" title="struct scram::client::ScramClient">ScramClient</a>;</code></td></tr><tr><td><code>pub use server::<a class="trait" href="../scram/server/trait.AuthenticationProvider.html" title="trait scram::server::AuthenticationProvider">AuthenticationProvider</a>;</code></td></tr><tr><td><code>pub use server::<a class="enum" href="../scram/server/enum.AuthenticationStatus.html" title="enum scram::server::AuthenticationStatus">AuthenticationStatus</a>;</code></td></tr><tr><td><code>pub use server::<a class="struct" href="../scram/server/struct.PasswordInfo.html" title="struct scram::server::PasswordInfo">PasswordInfo</a>;</code></td></tr><tr><td><code>pub use server::<a class="struct" href="../scram/server/struct.ScramServer.html" title="struct scram::server::ScramServer">ScramServer</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="mod" href="client/index.html"
                                  title='mod scram::client'>client</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="server/index.html"
                                  title='mod scram::server'>server</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Error.html"
                                  title='enum scram::Error'>Error</a></td>
                           <td class='docblock-short'>
                                <p>The SCRAM mechanism error cases.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Field.html"
                                  title='enum scram::Field'>Field</a></td>
                           <td class='docblock-short'>
                                <p>The fields used in the exchanged messages.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Kind.html"
                                  title='enum scram::Kind'>Kind</a></td>
                           <td class='docblock-short'>
                                <p>The kinds of protocol errors.</p>

                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.hash_password.html"
                                  title='fn scram::hash_password'>hash_password</a></td>
                           <td class='docblock-short'>
                                <p>Hashes a password with SHA-256 with the given salt and number of iterations.  This should
be used by <a href="server/trait.AuthenticationProvider.html"><code>AuthenticationProvider</code></a> implementors
to hash any passwords prior to being saved.</p>

                           </td>
                       </tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "scram";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>